"""
Let's make a table.

I'm not sure this is literally going to be Table 1, but it is the first table that 
needs to be generated by code.

"""

import os
import warnings

import astropy.units as u
import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
import wuvars.analysis.variability_selection as sv
from astropy.coordinates import SkyCoord
from astropy.io import ascii
from astropy.table import Table
from wuvars.analysis.bd_matching_v3 import match_ic, match_ngc
from wuvars.analysis.spectral_type_to_number import get_SpT_from_num
from wuvars.analysis.variability_selection_curved import (curve_Stetson, sv_hk,
                                                          sv_jh, sv_jhk, sv_jk)
from wuvars.data import photometry, quality_classes, spreadsheet
from wuvars.tables.make_tables import table_export_path

# This part pulls up the source information from our position-matching scheme.
ngc_match = match_ngc()
ic_match = match_ic()

region_keys = ["ic", "ngc"]
region_shorthand = {"ic": 'ic348', "ngc": 'ngc1333'}
wserv_dict = {"ngc": 7, "ic": 8}
fullname_dict = {"ngc": "NGC 1333", "ic": "IC 348"}
match_dict = {"ngc": ngc_match, "ic": ic_match}
index_dict = {"ic": "L16_T1_index", "ngc": "L16_T2_index"}
spread_dict = {"ngc": spreadsheet.load_wserv_v2(7), "ic": spreadsheet.load_wserv_v2(8)}
q_dict = {"ngc": quality_classes.load_q(7), "ic": quality_classes.load_q(8)}
# qm_dict = {
#     "ngc": pd.read_hdf(os.path.join(os.getcwd(), "ngc_QM.h5")).set_index("SOURCEID"),
#     "ic": pd.read_hdf(os.path.join(os.getcwd(), "ic_QM.h5")).set_index("SOURCEID"),
# }


def build_other_names(row, name_columns):
    """
    Concatenate all non-empty values from the given name columns into a single string.
    Safe against missing columns (for different regions).
    """
    names = []
    for col in name_columns:
        try:
            if col in row.colnames:  # works if row is a Table row
                val = row[col]
            else:
                continue
        except Exception:
            continue

        if (
            val is not None
            and val != "--"
            and not (isinstance(val, str) and val.strip() == "")
        ):
            names.append(str(val).strip())

    return ", ".join(names) if names else "--"


def build_other_names_latex(row, name_columns):
    """
    Condense 'Other Names' for LaTeX display.

    Rules:
    - Return an empty string if there are no names.
    - If exactly one name exists, return it as-is.
    - If more than one exists, return the first followed by ', (...)'.
    """
    names = []

    for col in name_columns:
        try:
            val = row[col]
        except KeyError:
            continue  # column not present in this dataset
        if val is not None and str(val).strip() not in ("", "nan", "None", '--'):
            names.append(str(val).strip())

    if len(names) == 0:
        return ""
    elif len(names) == 1:
        return names[0]
    else:
        return f"{names[0]}, (...)"


# Columns that should be combined into 'OtherNames'
name_columns = [
    "Strom",
    "Aspin",
    "Lada",
    "Getman",
    "Wilking",
    "Gutermuth",
    "Oasa",
    "Evans",
    "Scholz",
    "Winston",
    "Rebull",
    "Luhman",
    "Stelzer",
    "AlvesdeOliveira",
]


def make_table_1_targets(verbose=False):
    """
    Makes a table, in both MRT and LaTeX formats

    Desired columns:
    - Canonical name (verbatim from Luhman t1/t2)
    - Shorthand name (maybe something as simple as ngc-1333-0, 
      or something... could be the index of the object in Luhman's t1 or t2)
    - Other names (as listed in Luhman16)
    - Region
    - Coordinates (RA / Dec)
    - Assigned spectral type
    - Median photometry at J, H, K, with error bars
      (note: this is 3 columns in the LaTeX but six columns in the MRT)
    - IR excess status (from L16)


    Only `approved` objects appear here. Objects not in `approved` could perhaps
    be relegated to a table in the appendix.    

    This is explicitly not a table about variability properties. 
    Nothing on that appears here. Not even data quality flags, etc. 
    I even feel a little 'borderline' including our median JHK photometry, but
    it seems like the right place to put it.

    """

    # function goes here
    # please output the full table to ApJ-compliant MRT,
    #  plus a 10-row sample (first ten rows) output to LaTeX

    rows = []

    for region_key in region_keys:  # "ngc", "ic"
        approved = match_dict[region_key].approved

        if verbose: print(region_key)

        for i, row in enumerate(approved):

            if verbose: 
                if i % 10 == 0: 
                    print(i)

            # Desired columns:
            # - Canonical name (verbatim from Luhman t1/t2)
            source_name = row["Name"]

            # - Shorthand name (maybe something as simple as ngc-1333-0,
            #   or something... could be the index of the object in Luhman's t1 or t2)
            shorthand = (
                f"{region_shorthand[region_key]}-{row[index_dict[region_key]]:03d}"  # synthetic shorthand
            )

            # - Other names (as listed in Luhman16)
            other_names = build_other_names(row, name_columns)
            other_names_latex = build_other_names_latex(row, name_columns)

            # - Region
            region_name = fullname_dict[region_key]

            # - Coordinates (RA / Dec)
            ra_deg = (row["RA"]  * u.rad ).to(u.deg)
            dec_deg = (row["DEC"] * u.rad).to(u.deg)

            # - Assigned spectral type
            SpT = row["Adopt"]

            # - Median photometry at J, H, K, with error bars
            #   (note: this is 3 columns in the LaTeX but six columns in the MRT)

            jmag, jerr = row["Jmag"], row["e_Jmag"]
            hmag, herr = row["Hmag"], row["e_Hmag"]
            kmag, kerr = row["Ksmag"], row["e_Ksmag"]

            # Question to resolve: are there EVER sources with valid JHK photometry in
            # the L16 table but no measurement here?
            jmag2, jerr2 = row["median_JAPERMAG3"], row["median_JAPERMAG3ERR"]
            hmag2, herr2 = row["median_HAPERMAG3"], row["median_HAPERMAG3ERR"]
            kmag2, kerr2 = row["median_KAPERMAG3"], row["median_KAPERMAG3ERR"]

            # Answer: there are four sources where we have `null` (at J and/or H) and 
            #         L16 has data. 
            #         Therefore

            # - IR excess status (from L16)
            ir_flag = row["IRexc"]

            rows.append(
                (
                    source_name,
                    shorthand,
                    other_names,
                    other_names_latex,
                    region_name,
                    ra_deg,
                    dec_deg,
                    SpT,
                    jmag,
                    jerr,
                    hmag,
                    herr,
                    kmag,
                    kerr,
                    jmag2,
                    jerr2,
                    hmag2,
                    herr2,
                    kmag2,
                    kerr2,
                    ir_flag,
                )
            )

            # --- Base MRT table ---
            table = Table(
                rows=rows,
                names=(
                    "Canonical",
                    "ShortName",
                    "OtherNames",
                    "OtherNamesLaTeX",
                    "Region",
                    "RA",
                    "Dec",
                    "SpT",
                    "Jmag",
                    "e_Jmag",
                    "Hmag",
                    "e_Hmag",
                    "Kmag",
                    "e_Kmag",
                    "Jmag2",
                    "e_Jmag2",
                    "Hmag2",
                    "e_Hmag2",
                    "Kmag2",
                    "e_Kmag2",
                    "IRexcess",
                ),
                # dtype=(
                #     "S30",
                #     "S20",
                #     "S100",
                #     "S12",
                #     "f8",
                #     "f8",
                #     "S12",
                #     "f4",
                #     "f4",
                #     "f4",
                #     "f4",
                #     "f4",
                #     "f4",
                #     "f4",
                #     "f4",
                #     "f4",
                #     "f4",
                #     "f4",
                #     "f4",
                #     "S3",
                # ),
            )
            # Units for MRT
            table["RA"].unit = u.deg
            table["Dec"].unit = u.deg
            for col in ("Jmag", "Hmag", "Kmag", "e_Jmag", "e_Hmag", "e_Kmag"):
                table[col].unit = u.mag

    # Output paths
    outpath_mrt = os.path.join(table_export_path, "table1_targets_mrt.txt")
    outpath_tex = os.path.join(table_export_path, "table1_targets_sample.tex")

    table_tex = table.copy()

    table.remove_columns("OtherNamesLaTeX")

    # --- Write MRT version ---
    ascii.write(table, outpath_mrt, format="mrt", overwrite=True)

    # Trying something here...
    # --- Build LaTeX-friendly copy ---
    coords = SkyCoord(ra=table_tex["RA"], dec=table_tex["Dec"])

    table_tex["RA"] = coords.ra.to_string(unit=u.hour, sep=":", precision=1,
                                          pad=True, alwayssign=False)
    table_tex["Dec"] = coords.dec.to_string(unit=u.deg, sep=":", precision=2,
                                            pad=True, alwayssign=True)

    # Collapse mags into "value ± err" strings
    def format_mag(val, err):
        if np.isfinite(val) and np.isfinite(err):
            return f"{val:.2f} ± {err:.2f}"
        elif np.isfinite(val):
            return f"{val:.2f}"
        else:
            return "..."

    jcol = [format_mag(v, e) for v, e in zip(table["Jmag"], table["e_Jmag"])]
    hcol = [format_mag(v, e) for v, e in zip(table["Hmag"], table["e_Hmag"])]
    kcol = [format_mag(v, e) for v, e in zip(table["Kmag"], table["e_Kmag"])]

    # Drop separate error columns
    table_tex.remove_columns(["Jmag","e_Jmag","Hmag","e_Hmag","Kmag","e_Kmag"])
    table_tex.remove_columns(["Jmag2","e_Jmag2","Hmag2","e_Hmag2","Kmag2","e_Kmag2"])
    table_tex.remove_columns(["OtherNames"])
    table_tex["J (mag)"] = jcol
    table_tex["H (mag)"] = hcol
    table_tex["K (mag)"] = kcol

    # Rename some headers for publication readability
    table_tex.rename_column("RA", "RA (J2000)")
    table_tex.rename_column("Dec", "Dec (J2000)")
    table_tex.rename_column("IRexcess", "IR excess")

    table_tex.rename_column("Canonical", "Name")
    table_tex.rename_column("OtherNamesLaTeX", "Other Names")    


    # Write LaTeX sample (first 10 rows)
    ascii.write(table_tex[:10], outpath_tex, format="aastex", overwrite=True)

    print(f"Wrote full MRT table to {outpath_mrt}")
    print(f"Wrote LaTeX sample to {outpath_tex}")

if __name__ == "__main__":
    make_table_1_targets(verbose=True)
